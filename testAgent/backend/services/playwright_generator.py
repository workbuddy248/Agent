"""
Enhanced Playwright Generator Service - Uses Azure OpenAI for test generation
File: backend/services/playwright_generator.py
"""

import logging
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
import json
import re
from datetime import datetime
from services.azure_openai_service import azure_openai_service

logger = logging.getLogger(__name__)

@dataclass
class TestCase:
    """Generated test case"""
    name: str
    description: str
    code: str
    setup_code: Optional[str] = None
    teardown_code: Optional[str] = None

class PlaywrightGeneratorService:
    """Enhanced service for generating Playwright test code using Azure OpenAI"""
    
    def __init__(self):
        self.base_imports = [
            "import { test, expect, Page, BrowserContext } from '@playwright/test';",
            ""
        ]
        self.azure_openai = azure_openai_service
        
    async def initialize(self):
        """Initialize the playwright generator service"""
        # Initialize Azure OpenAI service
        await self.azure_openai.initialize()
        logger.info("PlaywrightGeneratorService initialized with Azure OpenAI")
        
    async def generate_playwright_test(self, workflow_name: str, tdd_template: str, 
                                      cluster_config: Dict[str, Any]) -> str:
        """
        Generate Playwright test code using Azure OpenAI
        
        Args:
            workflow_name: Name of the workflow
            tdd_template: TDD template content
            cluster_config: Cluster configuration (url, username, password)
            
        Returns:
            Complete Playwright TypeScript test code generated by Azure OpenAI
        """
        logger.info(f"Generating Playwright test for workflow: {workflow_name} using Azure OpenAI")
        
        try:
            # Use Azure OpenAI to generate the test
            playwright_code = await self.azure_openai.generate_playwright_test(
                tdd_template=tdd_template,
                cluster_config=cluster_config,
                workflow_name=workflow_name
            )
            
            # Validate the generated code
            if not self._validate_generated_code(playwright_code):
                logger.warning(f"Generated code validation failed for {workflow_name}, falling back to basic generation")
                # Fallback to basic generation if Azure OpenAI fails
                playwright_code = self._generate_basic_playwright_test(
                    workflow_name, tdd_template, 
                    cluster_config.get('url', ''),
                    cluster_config.get('username', ''),
                    cluster_config.get('password', '')
                )
            
            logger.info(f"Generated Playwright test for {workflow_name}: {len(playwright_code)} characters")
            return playwright_code
            
        except Exception as e:
            logger.error(f"Failed to generate Playwright test using Azure OpenAI for {workflow_name}: {str(e)}")
            logger.info(f"Falling back to basic generation for {workflow_name}")
            
            # Fallback to basic generation
            return self._generate_basic_playwright_test(
                workflow_name, tdd_template,
                cluster_config.get('url', ''),
                cluster_config.get('username', ''),
                cluster_config.get('password', '')
            )
    
    def _validate_generated_code(self, code: str) -> bool:
        """Validate that the generated code is proper Playwright test code"""
        try:
            # Check for essential Playwright elements
            required_elements = [
                "test(",
                "async",
                "page",
                "expect"
            ]
            
            # Check if all required elements are present
            for element in required_elements:
                if element not in code:
                    logger.warning(f"Generated code missing required element: {element}")
                    return False
            
            # Check for basic TypeScript syntax
            if code.count('{') != code.count('}'):
                logger.warning("Generated code has mismatched braces")
                return False
            
            # Check for minimum length
            if len(code.strip()) < 100:
                logger.warning("Generated code is too short")
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"Error validating generated code: {str(e)}")
            return False
    
    async def test_connection(self) -> Dict[str, Any]:
        """Test Azure OpenAI connection"""
        try:
            return await self.azure_openai.test_connection()
        except Exception as e:
            logger.error(f"Azure OpenAI connection test failed: {str(e)}")
            return {
                "status": "error",
                "message": f"Azure OpenAI connection failed: {str(e)}",
                "timestamp": datetime.now().isoformat()
            }
    
    # Fallback methods (keep existing implementation as backup)
    def _generate_basic_playwright_test(self, workflow_name: str, tdd_template: str,
                                      cluster_url: str, username: str, password: str) -> str:
        """Generate a basic Playwright test structure (fallback)"""
        
        # Sanitize workflow name for test function
        sanitized_name = workflow_name.replace('_', ' ').title().replace(' ', '')
        
        # Extract test cases from TDD template
        test_cases = self._extract_test_cases_from_tdd(tdd_template)
        
        # Generate the Playwright test
        playwright_code = f'''import {{ test, expect, Page }} from '@playwright/test';

test.describe('{workflow_name} Tests', () => {{
  let page: Page;

  test.beforeEach(async ({{ browser }}) => {{
    page = await browser.newPage();
    // Setup for {workflow_name}
  }});

  test.afterEach(async () => {{
    await page.close();
  }});

'''
        
        # Add test cases
        for i, test_case in enumerate(test_cases):
            test_function = self._generate_test_function_from_case(test_case, cluster_url, username, password)
            playwright_code += test_function + '\n\n'
        
        # Close the describe block
        playwright_code += '});'
        
        return playwright_code
    
    def _extract_test_cases_from_tdd(self, tdd_template: str) -> List[Dict[str, Any]]:
        """Extract test cases from TDD template"""
        test_cases = []
        
        # Split template into sections
        sections = tdd_template.split('\n\n')
        current_test = None
        
        for section in sections:
            lines = section.strip().split('\n')
            if not lines:
                continue
                
            first_line = lines[0].strip()
            
            # Check if this is a test case name
            if first_line.startswith('test_') and not first_line.startswith('Given:'):
                if current_test:
                    test_cases.append(current_test)
                
                current_test = {
                    'name': first_line,
                    'steps': []
                }
            elif current_test and (first_line.startswith('Given:') or 
                                 first_line.startswith('When:') or 
                                 first_line.startswith('Then:')):
                # Add steps to current test
                for line in lines:
                    if line.strip() and (line.startswith('Given:') or 
                                       line.startswith('When:') or 
                                       line.startswith('Then:')):
                        current_test['steps'].append(line.strip())
        
        # Add the last test case
        if current_test:
            test_cases.append(current_test)
        
        return test_cases
    
    def _generate_test_function_from_case(self, test_case: Dict[str, Any],
                                        cluster_url: str, username: str, password: str) -> str:
        """Generate a Playwright test function from a test case"""
        
        test_name = test_case['name']
        steps = test_case.get('steps', [])
        
        # Create test function
        test_code = f'''  test('{test_name.replace('_', ' ')}', async () => {{
    // Test: {test_name}
    
    // Navigate to cluster
    await page.goto('{cluster_url}');
    
'''
        
        # Convert TDD steps to Playwright actions
        for step in steps:
            playwright_action = self._convert_tdd_step_to_playwright(step, username, password)
            if playwright_action:
                test_code += f'    {playwright_action}\n'
        
        test_code += '  });'
        
        return test_code
    
    def _convert_tdd_step_to_playwright(self, step: str, username: str, password: str) -> str:
        """Convert a TDD step to Playwright action"""
        
        step_lower = step.lower()
        
        # Handle different types of steps
        if step.startswith('Given:'):
            return f'// Setup: {step[6:].strip()}'
        
        elif step.startswith('When:') and 'navigate' in step_lower:
            return 'await page.goto(arguments[0]);'
        
        elif step.startswith('When:') and 'enter' in step_lower and 'username' in step_lower:
            return f"await page.fill('input[name=\"username\"], input[id=\"username\"]', '{username}');"
        
        elif step.startswith('When:') and 'enter' in step_lower and 'password' in step_lower:
            return f"await page.fill('input[type=\"password\"]', '{password}');"
        
        elif step.startswith('When:') and 'click' in step_lower and 'login' in step_lower:
            return "await page.click('button[type=\"submit\"], button:has-text(\"login\"), button:has-text(\"sign in\")');"
        
        elif step.startswith('When:') and 'click' in step_lower:
            # Extract what to click from the step
            click_target = step[5:].strip().replace('The user clicks on', '').replace('clicks on', '').strip()
            return f"await page.click('text={click_target}');"
        
        elif step.startswith('Then:') and 'should' in step_lower:
            if 'home page' in step_lower:
                return "await expect(page).toHaveURL(/home|dashboard|main/);"
            elif 'title' in step_lower:
                return "await expect(page.locator('title, h1, .title')).toBeVisible();"
            else:
                return f"// Verify: {step[5:].strip()}"
        
        else:
            return f"// {step}"
    
    # Keep all existing methods for backward compatibility
    def generate_test_from_steps(self, 
                                test_name: str, 
                                steps: List[Dict[str, Any]], 
                                base_url: str = None) -> TestCase:
        """Generate a complete Playwright test from steps"""
        
        # Generate test description
        description = f"Generated test: {test_name}"
        
        # Generate test code
        test_code = self._generate_test_function(test_name, steps, base_url)
        
        return TestCase(
            name=test_name,
            description=description,
            code=test_code
        )
    
    def _generate_test_function(self, 
                               test_name: str, 
                               steps: List[Dict[str, Any]], 
                               base_url: str = None) -> str:
        """Generate the main test function"""
        
        code_lines = []
        code_lines.extend(self.base_imports)
        
        # Test function header
        sanitized_name = re.sub(r'[^a-zA-Z0-9_]', '_', test_name)
        code_lines.append(f"test('{test_name}', async ({{ page }}) => {{")
        
        # Setup
        if base_url:
            code_lines.append(f"  // Navigate to base URL")
            code_lines.append(f"  await page.goto('{base_url}');")
            code_lines.append("")
        
        # Generate steps
        for i, step in enumerate(steps):
            step_code = self._generate_step_code(step, i + 1)
            if step_code:
                code_lines.extend(step_code)
                code_lines.append("")
        
        code_lines.append("});")
        
        return "\n".join(code_lines)
    
    def _generate_step_code(self, step: Dict[str, Any], step_number: int) -> List[str]:
        """Generate code for a single step"""
        code_lines = []
        
        # Add comment with original instruction
        if "raw_instruction" in step:
            code_lines.append(f"  // Step {step_number}: {step['raw_instruction']}")
        
        action = step.get("action", "")
        method = step.get("method", "")
        
        if action == "navigation" or method == "page.goto":
            target = step.get("target", "")
            if target:
                code_lines.append(f"  await page.goto('{target}');")
        
        elif action == "click" or method == "page.click":
            selector = step.get("selector", "")
            if selector:
                code_lines.append(f"  await page.click('{selector}');")
        
        elif action == "fill" or method == "page.fill":
            selector = step.get("selector", "")
            value = step.get("value", "")
            if selector and value:
                code_lines.append(f"  await page.fill('{selector}', '{value}');")
        
        elif action == "wait" or method.startswith("page.wait_for"):
            if method == "page.wait_for_timeout":
                timeout = step.get("timeout", 1000)
                code_lines.append(f"  await page.waitForTimeout({timeout});")
            elif method == "page.wait_for_selector":
                selector = step.get("selector", "")
                if selector:
                    code_lines.append(f"  await page.waitForSelector('{selector}');")
        
        elif action == "assert" or method == "expect":
            condition = step.get("condition", "")
            if condition:
                # Try to convert natural language condition to Playwright assertion
                assertion_code = self._generate_assertion(condition)
                if assertion_code:
                    code_lines.append(f"  {assertion_code}")
        
        return code_lines
    
    def _generate_assertion(self, condition: str) -> str:
        """Generate Playwright assertion from natural language condition"""
        condition = condition.lower().strip()
        
        # Common assertion patterns
        if "page title" in condition and "contains" in condition:
            # Extract expected title
            title_match = re.search(r"contains\s+['\"]([^'\"]+)['\"]", condition)
            if title_match:
                expected_title = title_match.group(1)
                return f"await expect(page).toHaveTitle(/{expected_title}/i);"
        
        elif "url" in condition and "contains" in condition:
            # Extract expected URL part
            url_match = re.search(r"contains\s+['\"]([^'\"]+)['\"]", condition)
            if url_match:
                expected_url = url_match.group(1)
                return f"await expect(page).toHaveURL(/{expected_url}/);"
        
        elif "text" in condition and "visible" in condition:
            # Extract expected text
            text_match = re.search(r"text\s+['\"]([^'\"]+)['\"]", condition)
            if text_match:
                expected_text = text_match.group(1)
                return f"await expect(page.locator('text={expected_text}')).toBeVisible();"
        
        elif "element" in condition and "visible" in condition:
            # Extract selector
            element_match = re.search(r"element\s+['\"]([^'\"]+)['\"]", condition)
            if element_match:
                selector = element_match.group(1)
                return f"await expect(page.locator('{selector}')).toBeVisible();"
        
        # Default assertion
        return f"// TODO: Implement assertion for: {condition}"
    
    def generate_test_suite(self, 
                           suite_name: str, 
                           test_cases: List[TestCase]) -> str:
        """Generate a complete test suite file"""
        
        code_lines = []
        code_lines.extend(self.base_imports)
        
        # Add test.describe block
        code_lines.append(f"test.describe('{suite_name}', () => {{")
        code_lines.append("")
        
        # Add each test case
        for test_case in test_cases:
            # Extract just the test function from the test case code
            test_function = self._extract_test_function(test_case.code)
            if test_function:
                indented_lines = ["  " + line for line in test_function.split("\n")]
                code_lines.extend(indented_lines)
                code_lines.append("")
        
        code_lines.append("});")
        
        return "\n".join(code_lines)
    
    def _extract_test_function(self, test_code: str) -> str:
        """Extract just the test function from complete test code"""
        lines = test_code.split("\n")
        
        # Find the start of the test function
        start_index = -1
        for i, line in enumerate(lines):
            if line.strip().startswith("test("):
                start_index = i
                break
        
        if start_index == -1:
            return test_code
        
        # Return everything from the test function onwards
        return "\n".join(lines[start_index:])
    
    def add_test_hooks(self, 
                      test_code: str, 
                      setup_code: str = None, 
                      teardown_code: str = None) -> str:
        """Add beforeEach and afterEach hooks to test code"""
        
        lines = test_code.split("\n")
        result_lines = []
        
        # Add imports if not present
        if not any("import" in line for line in lines[:5]):
            result_lines.extend(self.base_imports)
        
        # Find describe block or add one
        describe_start = -1
        for i, line in enumerate(lines):
            if "test.describe(" in line:
                describe_start = i
                break
        
        if describe_start == -1:
            # No describe block, add one
            result_lines.append("test.describe('Generated Tests', () => {")
            
            # Add hooks
            if setup_code:
                result_lines.append("  test.beforeEach(async ({ page }) => {")
                for line in setup_code.split("\n"):
                    if line.strip():
                        result_lines.append(f"    {line}")
                result_lines.append("  });")
                result_lines.append("")
            
            if teardown_code:
                result_lines.append("  test.afterEach(async ({ page }) => {")
                for line in teardown_code.split("\n"):
                    if line.strip():
                        result_lines.append(f"    {line}")
                result_lines.append("  });")
                result_lines.append("")
            
            # Add existing test functions with indentation
            for line in lines:
                if line.strip() and not line.startswith("import"):
                    result_lines.append(f"  {line}")
            
            result_lines.append("});")
        else:
            # Insert hooks into existing describe block
            result_lines.extend(lines[:describe_start + 1])
            
            if setup_code:
                result_lines.append("  test.beforeEach(async ({ page }) => {")
                for line in setup_code.split("\n"):
                    if line.strip():
                        result_lines.append(f"    {line}")
                result_lines.append("  });")
                result_lines.append("")
            
            if teardown_code:
                result_lines.append("  test.afterEach(async ({ page }) => {")
                for line in teardown_code.split("\n"):
                    if line.strip():
                        result_lines.append(f"    {line}")
                result_lines.append("  });")
                result_lines.append("")
            
            result_lines.extend(lines[describe_start + 1:])
        
        return "\n".join(result_lines)